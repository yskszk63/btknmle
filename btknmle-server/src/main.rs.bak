use std::io;

use bytes::{Bytes, BytesMut, IntoBuf};
use futures::{SinkExt as _, StreamExt as _};
use tokio::codec::{Decoder, Encoder};
use either::{Left, Right};

use btknmle_pkt::{self as pkt, Codec as _, HciPacket};
use btknmle_pkt::att::Handle as AttHandle;
use btknmle_sock::{HciFramed, HciSocket};

mod l2cap;
mod att;
mod gatt;

struct PacketCodec;

impl Encoder for PacketCodec {
    type Item = HciPacket;
    type Error = io::Error;

    fn encode(&mut self, item: Self::Item, buf: &mut BytesMut) -> Result<(), Self::Error> {
        item.write_to(buf).unwrap();
        Ok(())
    }
}

impl Decoder for PacketCodec {
    type Item = HciPacket;
    type Error = io::Error;

    fn decode(&mut self, buf: &mut BytesMut) -> Result<Option<Self::Item>, Self::Error> {
        let item = HciPacket::parse(&mut buf.take().into_buf()).unwrap();
        Ok(Some(item))
    }
}

#[tokio::main(single_thread)]
async fn main() {
    let sock = HciSocket::bind(0).unwrap();
    let mut frames = HciFramed::new(sock, PacketCodec);

    let pkt = HciPacket::Command(pkt::command::host_ctl::Reset::new().into());
    frames.send(pkt).await.unwrap();
    let pkt = frames.next().await.unwrap();
    println!("{:?}", &pkt);

    let mut b = [0; 31];
    b[0] = 0x02;
    b[1] = 0x01;
    b[2] = 0x06;
    let pkt = HciPacket::Command(pkt::command::le_ctl::LeSetAdvertisingData::new(3, b).into());
    frames.send(pkt).await.unwrap();
    let pkt = frames.next().await.unwrap();
    println!("{:?}", &pkt);

    let pkt = HciPacket::Command(pkt::command::le_ctl::LeSetAdvertiseEnable::new(true).into());
    frames.send(pkt).await.unwrap();
    let pkt = frames.next().await.unwrap();
    println!("{:?}", &pkt);

    let mut transport = att::AttTransport::new(l2cap::L2CapTransport::new(frames));
    loop {
        let p = transport.next().await.unwrap().unwrap();
        match p {
            Left((handle, data)) => {
                println!("{:?} {:?}", handle, data);

                match data {
                    pkt::att::Att::ReadByGroupTypeRequest(item) => {
                        if item.starting_handle() != AttHandle::from(0x01) {
                            let d = pkt::att::ErrorResponse::new(
                                0x10,//pkt::att::ReadByGroupTypeRequest::OPCODE,
                                item.starting_handle(),
                                pkt::att::ErrorCode::AttributeNotFound);
                            let d = pkt::att::Att::from(d);
                            transport.send((handle, d)).await.unwrap();
                        } else {
                            let d = pkt::att::ReadByGroupTypeResponse::builder(
                                0x0001, 0x0007, pkt::att::Uuid16::from(0x1800)).build();
                            let d = pkt::att::Att::ReadByGroupTypeResponse(d);
                            transport.send((handle, d)).await.unwrap();
                        }
                    },
                    pkt::att::Att::ReadByTypeRequest(item) => {
                        match (item.starting_handle(), item.attribute_type()) {
                            (pkt::att::Handle(0x01), pkt::att::Uuid::Uuid16(0x2803)) => {
                                let d = pkt::att::ReadByTypeResponse::builder(
                                    0x0002,
                                    Bytes::from(&[0x02, 0x03, 0x00, 0x00, 0x2a][..])).build();
                                let d = pkt::att::Att::from(d);
                                transport.send((handle, d)).await.unwrap();
                            },
                            (_, pkt::att::Uuid::Uuid16(0x2802)) |
                            (_, pkt::att::Uuid::Uuid16(0x2803)) => {
                                let d = pkt::att::ErrorResponse::new(
                                    0x08,//pkt::att::ReadByTypeRequest::OPCODE,
                                    item.starting_handle(),
                                    pkt::att::ErrorCode::AttributeNotFound);
                                let d = pkt::att::Att::from(d);
                                transport.send((handle, d)).await.unwrap();
                            },
                            x => unimplemented!("{:?}", x),
                        };
                    },
                    pkt::att::Att::FindInformationRequest(item) => {
                        let d = pkt::att::ErrorResponse::new(
                            0x05,//pkt::att::FindInformationResponse::OPCODE,
                            item.starting_handle(),
                            pkt::att::ErrorCode::AttributeNotFound);
                        let d = pkt::att::Att::from(d);
                        transport.send((handle, d)).await.unwrap();
                    },
                    pkt::att::Att::ReadRequest(..) => {
                        let d = pkt::att::ReadResponse::new("HELLO WORLD!");
                        let d = pkt::att::Att::from(d);
                        transport.send((handle, d)).await.unwrap();
                    },
                    x => unimplemented!("{:?}", x),
                };
            },
            Right(e) => {
                println!("{:?}", e);
            }
        }
    }
}
